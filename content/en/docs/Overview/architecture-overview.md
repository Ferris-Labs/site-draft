---
title: "Architecture Overview"
linkTitle: "Architecture Overview"
weight: 100
description: >-
     An Overview of the architecture of FerrisFX.
---

## Concepts

FerrisFX is based on 2 simple concepts - **Services** and **Events**

**On FX you are effectively writing large applications by connecting “blocks” of code through Events. **

Each Service is a self contained piece of functionality like loading a file, running a view rebuild or launching a container. You can link and re-link the blocks of code at anytime you like. 

The source code can be as big or as tiny as you like. 

You are not required to think in terms of pre-defined DAGS and can rapidly and iteratively build, test and deploy your applications.

### Services

**SERVICES** are collections of scripts and modules which are executed in sequence by the **FX Executor**. 

Services are triggered by **EVENTS**, which are JSON messages which carry a header and payload. A Service can be Linked to one or more events.

Each script is provided with the Payload of the Event that triggered it. It is the job of the **FX Router** to send Events to the appropriate Service.

The following is a basic Service which parses the event sent to it and prints the payload.

```python
import sys
import json

def hello_world(payload):
  print(payload)

payload = json.loads(sys.arg[1])

hello_world(payload)
```

### Events

Events are messages passed through the platform which are generated by Services.

Events are in the form of JSON formatted which adheres to the CloudEvents format. They carry a Header which indicates the event type and a Payload (or Data section) which contain information about the event. 

The following is a sample Event.

```json
{
    "specversion" : "1.0",
    "type" : "com.example.someevent", // The Event Type
    "source" : "/mycontext",
    "subject": null,
    "id" : "C234-1234-1234",
    "time" : "2018-04-05T17:31:00Z",
    "datacontenttype" : "application/json",
    "data" : {                       // The event payload as JSON
        "appinfoA" : "abc",
        "appinfoB" : 123,
        "appinfoC" : true
    }
}
```

### Service Triggering

Services can be triggered in the following ways

- Manually: By clicking on the 'Run' button on the FerrisFX Management Server.
- On Schedule: As a cron job whereas the Cron expression is added on the UI
- On Event: Where a package is configured to be triggered bt the FX Router when a specific type of event is observed on the platform.

Irrespective of how a Service is triggered it is always triggered by an Event. In the case of Manual and Scheduled triggering it is the FX platform that generates the trigger event.

### Late Linking

One of the most important features of the FX Platform is that you are not required to link the Service to an Event during the course of development. And you can also change the Trigger Event(s) post-deployment. 

**On FX you are effectively write large applications by connecting “blocks” of code. Each node – as we refer to them – is a self contained piece of functionality like loading a file, running a view rebuild or launching a container. The source code can be as big or as tiny as you like.** 

This approach gives you a great flexibility to 

* not having to think of pre-defined flows but to build the Flow as well as the Services iteratively.
* maintain and test multiple versions of the same Service in parallel.



## The FerrisFX Flow

The FerrisFX platform is an Async platform. At the core of the platform messages(Events) are passed through the **Kafka Message Bus**. These 'events' are JSON formatted messages which adhere to the CloudEvents format. 

![image-20211023085329814](/images/diagram_1.png)

Each **Event** consists of what may be simplified as Headers and Payload. The headers indicate the type of event and other attributes. Whereas the payload are the attributes or parameters that are sent out by Services in order to either provide information about their state or for usage by downstream Services.

The **FX Router(s)** is listening on the stream of Events passing through Kafka. Based on the configuration of the platform which is managed in the **Ferris Manager UI** the Router decides if a Service requires to be executed based on the Event contents. On finding a configured Handler the gateway sends a message to the Executor and informs it of which packages or scripts required to be run.

The **FX Executor(s)** downloads the Service from the **Minio** storage and executes the **Service**. The Service may use any Python module that is embedded in the Executor and also use **Consul** for storing its configurations. The Execuor sends a series of messages on Service execution and maintains track of the state of the execution and the metrics. These are once again processed by the gateway and stored either in **Postgres** or in **Elasticsearch** based on the type of message and the contents.



## Required Infrastructure

The following are the infrastructure components required for a FerrisFX installation

| Component         | Descriptio                                                   |
| ----------------- | ------------------------------------------------------------ |
| Apache Kafka      | Apache Kafka serves as the backbone to pass events and operational data within a FerrisFX Installation. |
| PostgresSQL       | Postgres is used as the database for the FerrisFX Manager Application. |
| Consul            | Consul is the configuration store used by the FerrisFX platform. It is also used by the services to store their configurations. |
| Minio             | Minio provides the platform internal storage for scripts and assets used by the Services |
| Elasticsearch     | Elasticsearch is used as a central store for all operational data. Thereby making the data easiliy searchable. |
| Kibana            | Kibana is used to view and query the data stored in Elasticsearch. |
| FerrisFX-Manager  | FerrisFX Manager is the main UI used for all activities on the FerrisFX platform. |
| FerrisFX-Router   | The Route container is responsible for listenting to events flowing through the system and forwarding the events to the appropriate micro-services that you create. |
| FerrisFX-Executor | The executor container(s) is where the code gets executed.   |

